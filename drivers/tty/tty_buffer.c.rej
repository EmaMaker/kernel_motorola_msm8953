diff a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c	(rejected hunks)
@@ -72,7 +72,7 @@ void tty_buffer_unlock_exclusive(struct tty_port *port)
 	atomic_dec(&buf->priority);
 	mutex_unlock(&buf->lock);
 	if (restart)
-		queue_kthread_work(&port->worker, &buf->work);
+		queue_work(system_unbound_wq, &buf->work);
 }
 EXPORT_SYMBOL_GPL(tty_buffer_unlock_exclusive);
 
@@ -133,8 +133,6 @@ void tty_buffer_free_all(struct tty_port *port)
 	buf->tail = &buf->sentinel;
 
 	atomic_set(&buf->mem_used, 0);
-	if (!IS_ERR_OR_NULL(port->worker_thread))
-		kthread_stop(port->worker_thread);
 }
 
 /**
@@ -220,10 +218,7 @@ void tty_buffer_flush(struct tty_struct *tty)
 	atomic_inc(&buf->priority);
 
 	mutex_lock(&buf->lock);
-	/* paired w/ release in __tty_buffer_request_room; ensures there are
-	 * no pending memory accesses to the freed buffer
-	 */
-	while ((next = smp_load_acquire(&buf->head->next)) != NULL) {
+	while ((next = buf->head->next) != NULL) {
 		tty_buffer_free(port, buf->head);
 		buf->head = next;
 	}
@@ -264,10 +259,7 @@ static int __tty_buffer_request_room(struct tty_port *port, size_t size,
 		if ((n = tty_buffer_alloc(port, size)) != NULL) {
 			n->flags = flags;
 			buf->tail = n;
-			/* paired w/ acquire in flush_to_ldisc(); ensures
-			 * flush_to_ldisc() sees buffer data.
-			 */
-			smp_store_release(&b->commit, b->used);
+			b->commit = b->used;
 			/* paired w/ barrier in flush_to_ldisc(); ensures the
 			 * latest commit value can be read before the head is
 			 * advanced to the next buffer
@@ -371,11 +363,8 @@ void tty_schedule_flip(struct tty_port *port)
 {
 	struct tty_bufhead *buf = &port->buf;
 
-	/* paired w/ acquire in flush_to_ldisc(); ensures
-	 * flush_to_ldisc() sees buffer data.
-	 */
-	smp_store_release(&buf->tail->commit, buf->tail->used);
-	queue_kthread_work(&port->worker, &buf->work);
+	buf->tail->commit = buf->tail->used;
+	schedule_work(&buf->work);
 }
 EXPORT_SYMBOL(tty_schedule_flip);
 
@@ -426,8 +415,6 @@ receive_buf(struct tty_struct *tty, struct tty_buffer *head, int count)
 			disc->ops->receive_buf(tty, p, f, count);
 	}
 	head->read += count;
-	if (count > 0)
-		memset(p, 0, count);
 	return count;
 }
 
@@ -444,7 +431,7 @@ receive_buf(struct tty_struct *tty, struct tty_buffer *head, int count)
  *		 'consumer'
  */
 
-static void flush_to_ldisc(struct kthread_work *work)
+static void flush_to_ldisc(struct work_struct *work)
 {
 	struct tty_port *port = container_of(work, struct tty_port, buf.work);
 	struct tty_bufhead *buf = &port->buf;
@@ -476,10 +463,7 @@ static void flush_to_ldisc(struct kthread_work *work)
 		 * is advancing to the next buffer
 		 */
 		smp_rmb();
-		/* paired w/ release in __tty_buffer_request_room() or in
-		 * tty_buffer_flush(); ensures we see the committed buffer data
-		 */
-		count = smp_load_acquire(&head->commit) - head->read;
+		count = head->commit - head->read;
 		if (!count) {
 			if (next == NULL)
 				break;
@@ -508,7 +492,7 @@ static void flush_to_ldisc(struct kthread_work *work)
  */
 void tty_flush_to_ldisc(struct tty_struct *tty)
 {
-	flush_kthread_work(&tty->port->buf.work);
+	flush_work(&tty->port->buf.work);
 }
 
 /**
@@ -547,18 +531,8 @@ void tty_buffer_init(struct tty_port *port)
 	init_llist_head(&buf->free);
 	atomic_set(&buf->mem_used, 0);
 	atomic_set(&buf->priority, 0);
+	INIT_WORK(&buf->work, flush_to_ldisc);
 	buf->mem_limit = TTYB_DEFAULT_MEM_LIMIT;
-	init_kthread_work(&buf->work, flush_to_ldisc);
-	init_kthread_worker(&port->worker);
-	port->worker_thread = kthread_run(kthread_worker_fn, &port->worker,
-					  "tty_worker_thread");
-	if (IS_ERR(port->worker_thread)) {
-		/*
-		 * Not good, we can't unwind, this tty is going to be really
-		 * sad...
-		 */
-		pr_err("Unable to start tty_worker_thread\n");
-	}
 }
 
 /**
